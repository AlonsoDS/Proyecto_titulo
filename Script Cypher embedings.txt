// file: cypher/per_apartment_per_class_local_fastrp.cypher
// PURPOSE
//   For each Departamento and each POI.class, build the apartment's ego‑graph (apartment + its POIs of that class),
//   run FastRP ONLY on that tiny subgraph, capture the apartment's vector, and write it to the apartment as emb_<class>.
//   This produces UNIQUE, local context embeddings per apartment per class for ML.
//
// REQS
//   - Neo4j 5.x + GDS 2.x, APOC core.
//   - Labels: :Departamento, :POI
//   - Rels: :CERCA_DE_CAT1|:CERCA_DE_CAT2|:CERCA_DE_CAT3 (Departamento -> POI) with r.distancia_metros
//   - POI has property `class` (string-like)
//
// CONFIG (adjust as needed)
:param cfg => {
  overwrite: false,              // if false, skip apartments that already have emb_<class>
  dim: 16,                      // embedding dimension
  iw: [1.0,0.5,0.25,0.125],     // iterationWeights (short paths emphasized)
  minPois: 1,                   // require at least N POIs in that class to compute; else write null
  batch: 50,                    // apoc.periodic.iterate batch size
  parallel: true,               // run inner work in parallel (ensure unique graph names)
  concurrency: 4                // adjust to CPU/memory; 4–8 often fine
};

// -----------------------------------------------------------------------------
// 0) Helper: sanitize a string to a safe key fragment (lowercase, [a-z0-9_])
// -----------------------------------------------------------------------------
CALL apoc.custom.asFunction(
  'sanitizeKey',
  'RETURN apoc.text.replace(toLower($s), "[^a-z0-9]+", "_") AS value',
  'string', [['s','STRING']], false,
  'Sanitize arbitrary strings to safe property/key suffixes') YIELD name;

// -----------------------------------------------------------------------------
// 1) Collect distinct POI classes and their safe keys
// -----------------------------------------------------------------------------
MATCH (p:POI)
WITH DISTINCT coalesce(toString(p.class),'unknown') AS poiClass
WITH poiClass, sanitizeKey(poiClass) AS key
RETURN poiClass, key
ORDER BY poiClass;

// -----------------------------------------------------------------------------
// 2) Main driver: iterate apartments × classes
//    - Skips if overwrite=false and property already exists
//    - For each pair, builds ego‑graph, runs FastRP in-memory, writes emb_<class>
// -----------------------------------------------------------------------------
CALL apoc.periodic.iterate(
  // outer: produce all (apartment, class, key) pairs we intend to process
  '
  MATCH (p:POI)
  WITH DISTINCT coalesce(toString(p.class),"unknown") AS poiClass
  WITH poiClass, sanitizeKey(poiClass) AS key
  // stream apartments; optionally filter by area, etc.
  MATCH (a:Departamento)
  // skip if embedding already exists and overwrite=false
  WHERE $cfg.overwrite OR NOT exists(a["emb_"+key])
  RETURN id(a) AS aId, poiClass, key
  ',
  // inner: for each pair, compute local FastRP and write to the apartment
  '
  // 2.1 Load apartment and its POIs of this class
  MATCH (a:Departamento) WHERE id(a) = $aId
  OPTIONAL MATCH (a)-[r:CERCA_DE_CAT1|CERCA_DE_CAT2|CERCA_DE_CAT3]->(p:POI)
    WHERE toString(p.class) = $poiClass
  WITH a, collect(DISTINCT p) AS pois, $poiClass AS poiClass, $key AS key
  WITH a, [x IN pois WHERE x IS NOT NULL] AS pois, poiClass, key
  WITH a, pois, poiClass, key, size(pois) AS n
  CALL apoc.do.when(
    n < $cfg.minPois,
    // Not enough POIs: write null and exit
    "SET a[\"emb_\" + $key] = NULL RETURN a",
    // Enough POIs: build ego‑graph projection and run FastRP
    '
      WITH a, pois, poiClass, key
      // Build node id list for GDS projection
      WITH a, pois, poiClass, key,
           [id(a)] + [id(p) IN pois | id(p)] AS nodeIds
      // Unique per-task in-memory graph name (avoid collisions under parallel)
      WITH a, pois, poiClass, key, nodeIds,
           "ego_" + key + "_" + toString(id(a)) + "_" + substring(toString(timestamp()),-6) AS gname
      // Drop if exists (very unlikely name collision, but safe)
      CALL gds.graph.exists({graphName: gname}) YIELD exists
      CALL apoc.do.when(exists,
        "CALL gds.graph.drop($g,false) YIELD graphName RETURN graphName",
        "RETURN $g AS graphName",
        {g:gname}) YIELD value AS _dropMaybe
      // Project ego subgraph with bidirectional edges and proximity weight
      CALL gds.graph.project.cypher(
        gname,
        'WITH $nodeIds AS ids MATCH (n) WHERE id(n) IN ids RETURN id(n) AS id, labels(n) AS labels',
        'WITH $nodeIds AS ids\n'
        + 'MATCH (d)-[r:CERCA_DE_CAT1|CERCA_DE_CAT2|CERCA_DE_CAT3]->(p)\n'
        + 'WHERE id(d) IN ids AND id(p) IN ids\n'
        + 'WITH id(d) AS s, id(p) AS t, (1.0 / (1.0 + coalesce(r.distancia_metros,1.0))) AS w\n'
        + 'UNWIND [[s,t,w],[t,s,w]] AS row\n'
        + 'RETURN row[0] AS source, row[1] AS target, row[2] AS weight',
        {parameters:{nodeIds: nodeIds}})
      YIELD graphName, nodeCount, relationshipCount
      // If graph has only the apartment or no rels, write null and cleanup
      WITH a, poiClass, key, graphName, nodeCount, relationshipCount
      CALL apoc.do.when(relationshipCount = 0 OR nodeCount < 2,
        'CALL gds.graph.drop($g) YIELD graphName AS _g RETURN $a AS a',
        '
          // Run FastRP in-memory and stream embeddings
          CALL gds.fastRP.stream({
            graph: $g,
            embeddingDimension: $cfg.dim,
            iterationWeights: $cfg.iw,
            relationshipWeightProperty: "weight"
          }) YIELD nodeId, embedding
          WITH $a AS a, gds.util.asNode(nodeId) AS n, embedding
          WHERE n:Departamento
          SET a["emb_" + $key] = embedding
          RETURN a
        ', {g:graphName, a:a}) YIELD value AS res
      WITH res AS a, graphName
      // Drop temp graph
      CALL gds.graph.drop(graphName) YIELD graphName AS _gone
      RETURN a
    ', {key:key}
  ) YIELD value AS _a
  RETURN 1 AS done
  ',
  {batchSize: $cfg.batch, parallel: $cfg.parallel, concurrency: $cfg.concurrency, params:{cfg:$cfg}})
YIELD batches, total, timeTaken, committedOperations, failedOperations, retries
RETURN batches, total, timeTaken, committedOperations, failedOperations, retries;

// -----------------------------------------------------------------------------
// 3) OPTIONAL: L2-normalize all emb_* on Departamentos (writes emb_*_norm)
// -----------------------------------------------------------------------------
CALL apoc.meta.nodeTypeProperties() YIELD nodeLabels, propertyName
WITH nodeLabels, propertyName
WHERE any(l IN nodeLabels WHERE l='Departamento') AND propertyName STARTS WITH 'emb_'
WITH collect(propertyName) AS keys
CALL {
  WITH keys
  MATCH (d:Departamento)
  WITH d, keys
  CALL apoc.cypher.doIt('
    WITH $d AS d, $keys AS keys
    UNWIND [k IN keys WHERE k ENDS WITH "_norm" = false] AS k
    WITH d, k, d[k] AS v
    WHERE v IS NOT NULL AND size(v)>0
    WITH d, k, v, sqrt(reduce(s=0.0, x IN v | s + x*x)) AS n
    WITH d, k, CASE WHEN n=0.0 THEN v ELSE [x IN v | x/n] END AS nv
    CALL apoc.create.setProperty(d, k + "_norm", nv) YIELD node
    RETURN 1 as ok
  ', {d:d, keys:keys}) YIELD value
  RETURN count(*) AS updated
}
RETURN 'normalized' AS status;

// -----------------------------------------------------------------------------
// 4) OPTIONAL: Export embeddings with dataset id for ML
//   Assumes your original dataset identifier is stored in d.id (string/int). Change if needed.
// -----------------------------------------------------------------------------
CALL apoc.export.csv.query('
  MATCH (d:Departamento)
  WITH d, [k IN keys(d) WHERE k STARTS WITH "emb_"] AS ks
  WITH d, apoc.map.fromPairs([k IN ks | [k, d[k]]]) AS emb
  RETURN d.id AS dataset_id, emb
', 'exports/apartment_local_embeddings.csv', {quotes:true, stream:false, bulkImport:false});
